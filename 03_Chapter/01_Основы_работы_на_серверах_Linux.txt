Основы работы на серверах Linux, работа с командной строкой

Из этого урока вы научитесь:
  • Управлять правами процессов и пользователями в системе.
  • Понимать разницу между sudo и su, уметь работать в системе без root.
  • Просматривать переменные окружения процесса.
  • Быстро перемещаться по истории и конструкции команд.
  • Самостоятельно запускать/завершать процесс в различных режимах.
  • Прописывать несложные юнит-файлы.
  • Просматривать логи процесса.


Хорошим тоном считается запускать сервисы не из-под пользователя root, а из-под сервисных аккаунтов.

Работа с пользователем
  Базовые команды:
    • useradd  -  создать новых пользователей.
	  # useradd [options] <new_user>
		Требует прав суперадминистратора.
		При создании пользователей командой useradd автоматически создаются
		  - одноимённая группа
		  - (в некоторых системах) домашний каталог пользователя.
	## в Debian рекомендуется использовать  adduser
		  
    • groupadd — поможет создать отдельную группу.
	## addgroup - в Debian
	
    • passwd — изменяет пароль пользователя.
    • usermod — для других изменений пользователя  (смена группы или домашнего каталога, может быть, блокировки)
    • userdel — удаляет пользователя.
	
  Информация о пользователях (в том числе сервисных) содердится в файле:
    /etc/passwd
	
  В файле /etc/shadow хранятся хеши паролей пользователей.
  Доступ имеет только суперпользователь.
  
  Залогиниться под другим пользователем прямо в shell:
    $ su <username>
  чаще используют такую запись:
    $ su - <username>		# воссоздать переменные окружения другого пользователя.

  Если нужно запустить команду разово:
    $ su -c 'id'
    Password:
    uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)
	
sudo
  - это расширенный аналог su.
  Команда позволяет настроить доступы отдельно для каждого пользователя или группы.
  Доступы описаны в файле /etc/sudoers
  Вносить изменения в /etc/sudoers ТОЛЬКО с помощью visudo

	
Содержимое файла настроек /etc/sudoers:

# User privilege specification
root    ALL=(ALL:ALL) ALL

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL

# Allow members of group sudo to execute any command
%sudo    ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on "#include" directives:
#includedir /etc/sudoers.d

--- Пояснение ---
  Настройки пользователя root:
  ALL=(ALL:ALL) ALL
    • Первое ALL = данное правило применяется ко ВСЕМ ХОСТАМ;
	• Второе ALL = указанный ПОЛЬЗОВАТЕЛЬ может запускать команды от лица ВСЕХ ПОЛЬЗОВАТЕЛЕЙ
	• Третье ALL = указанный ПОЛЬЗОВАТЕЛЬ может запускать команды от лица всех ГРУПП
	• Четвёртое ALL = данные правила применяются ВСЕМ КОМАНДАМ

  $ sudo -l → список разрешённых команд для пользователя.
  

???????????????????????????????????????????????????????????????????
? Что нужно прописать в папке /etc/sudoers.d/,					  ?
? чтобы пользователь jarservice мог без пароля переходить в root, ?
? подтягивая переменные окружения root, но не более того?         ?
???????????????????????????????????????????????????????????????????
	$ sudo visudo 
	jarservice ALL=(root) NOPASSWD:/usr/bin/su -
	

Чтобы сохранить журнал действий с sudo в файл, нужно добавить следующую директиву:
	Defaults    logfile="/var/log/sudo.log"
	
Можно сохранять ввод и вывод команд:

	Defaults        log_output
	Defaults        log_input
	Defaults        iolog_dir=/var/log/sudo-io/%{user}
	%admins         ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: ALL


Переменные окружения
  Каждый экземпляр оболочки в момент старта получает набор данных и настроек, которые и называются переменными окружения.
  Переменные окружения задаются
    • системой   или
	• пользователями
  и могут использоваться программами (которые запускаются из оболочки) во время их выполнения.
  Сами по себе переменные окружения представляют собой пары ключ-значение. 

	$ env (printenv) - вывести на экран текущие переменные окружения.
	
  Переменные окружения доступны всем дочерним процессам.
  Существуют переменные текущего процесса (shell'а).
  Эти переменные НЕ ПЕРЕДАЮТСЯ дочернему процессу.
  
  Различие локальных и глобальных переменных окружения на примере:
	$ LOCAL_VAR=A
	$ export GLOBAL_VAR=B
	$  echo $LOCAL_VAR
    > A
	$ echo $GLOBAL_VAR
    > B
	# вызываем процесс bash как дочерний:
	$ bash
	$ echo $LOCAL_VAR		# ничего не выводит
    >
	$ echo $GLOBAL_VAR
    > B

  ► Задать переменные окружения
    • для текущего сеанса: set
	• для текущего и дочерних процессов: export
	• для всех процессов (навсегда): в файле /etc/profile

  ♦ посмотреть переменные текущего процесса можно командой  set
  ‼ список переменных процесса доступен по PID: cat /proc/<pid>/environ
  

Мультиплексоры

  При удалённом входе в систему бывает очень удобно запускать терминал в фоновом режиме, чтобы отсоединять и подключать его в любой момент.
  Это реализуется с помощью ТЕРМИНАЛЬНОГО МУЛЬТИПЛЕКСОРА.
  
  Когда мультиплексор особенно полезен?
    • в условиях нестабильной связи;
	• в случае необходимости запуска процесса в шелле, но с возможностью отключения от него.

  Другие механизмы запуска процессов в фоне:
    • nohup			#  если на сервере нет screen или если не нужно возвращаться к исполняемому процессу
	• jobs
	• fg
	• bg
	• disown
	• reptyr

После запуска screen можно запустить любое приложение в обычном режиме, но терминал уже запускается как дочерний процесс.

$ ps -aux
  jarserv+   61929  0.0  0.0 231624  2884 ?        Rs   21:10   0:00 SCREEN
  jarserv+   61930  0.1  0.0 226556  5588 pts/1    Ss   21:10   0:00 /bin/bash
  jarserv+   61960  0.0  0.0 227456  3956 pts/1    R+   21:10   0:00 ps -aux

Пример на практике:
  Запускаем в сессии screen простой однострочник, который будет выводить инкрементальное число:
  $ I=0 && while true; do clear; echo $I; let I=${I}+1; sleep 10; done
  
#### Чтобы отсоединиться от экрана, нажимаем последовательно следующие клавиши:
#  Ctrl+a и d.
# Когда сеанс отключится, мы получим сообщение
	«[detached from...».
При этом терминал отсоединится.

  • вывести список сессий screen:
	$ screen -ls
(output):> 
There is a screen on:
    61929.pts-0.localhost    (Detached)
1 Socket in /run/screen/S-jarservice.

  • подключиться к сессии screen:
    $ screen -r 61929.pts-0.localhost

  # Сессий screen можно запускать несколько
  # Для удобства можно давать сессиям имена:
    $ screen -S my_screen
  # Отображаться командой $ screen -ls будет так:
  <PID>.my_screen


Краткий список горячих клавиш:

  • Ctrl+a c — создать ещё одну оболочку
  • Ctrl+a " — просмотреть список оболочек в текущем сеансе screen
  • Ctrl+a NUM — переключиться на NUM окно, где NUM - это номер окна
  • Ctrl+a A — переименовать окно
  • Ctrl+a S — разделить окно горизонтально
  • Ctrl+a | — разделить окно вертикально
  • Ctrl+a tab — переключиться в следующий терминал в пределах окна
  • Ctrl+a Ctrl+a — переключиться между предыдущим окном и текущим
  • Ctrl+a X — закрыть текущую оболочку
  • Ctrl+a Q — закрыть всё, кроме текущей оболочки

‼ tmux является более современным аналогом screen


systemd

  systemd — это самая популярная система инициализации в Linux.
  Предшественники:
    • System V (иногда называют SysV),
	• RUNINIT
	... и несколько других

  Система инициализации — это служба, которая запускается первой после загрузки ядра и, в свою очередь, запускает все процессы, работающие в системе.
  С помощью настроек системы инициализации можно, к примеру, запускать различные уровни выполнения сервера (runlevels или targets), управлять, и отслеживать работу служб (демонов, программ) и пользователей.
  
  systemd и автозапуск приложений при перезагрузке системы:
    - чтобы приложение стартовало при запуске сервера, нужно создать скрипт (на языке systemd, юнит(unit)-файл).
	В этом файле указывают:
	  • откуда запускать приложение,
	  • под каким пользователем
	  ...и другую информацию.
	После создания юнит-файла можно будет управлять запуском приложения через систему инициализации (systemd)
	и, например, добавить приложение в автозагрузку.
	Также появится возможность использовать стандартные утилиты для работы с логами приложения.
	
  Где нужно создавать юнит-файлы?
    - В зависимости от дистрибутива, в директории:
	• /lib/systemd/system/
	• /usr/lib/systemd/user/
	• /usr/lib/systemd/system/
      # это стандартные места складирования юнит-файлов для установленных пакетов
      # Существующие юнит-файлы изменять не рекомендуется
	• /etc/systemd/system/		# место для дополнительных юнит-файлов
	  # приоритет юнит-файлов в этой директории выше, чем у любых других файлов в системе
	  # ‼ Здесь же находятся ссылки на юнит-файлы из стандартной директории.
	  # Ссылка создаётся, когда выполняешь systemctl enable <unit-name>


  Существующие типы юнитов systemd

    • target — группирует модули
    • service — отвечает за запуск сервисов (служб) и поддерживает вызов интерпретаторов для исполнения пользовательских скриптов
    • mount — занимается монтированием файловых систем
    • automount — автомонтирование файловых систем, используется при обращении к точке монтирования
    • swap — отвечает за подключение файла подкачки
    • timer — запускает модули по расписанию, аналог cron
    • socket — запуск модуля при подключении к сокету
    • slice — группировка других модулей в контейнер (дерево) cgroups
    • device — использует реакцию на подключение какого-либо устройства
    • path — запуск модуля по событию доступа по конкретному пути в файловой системе

  Управление процессами systemd происходит с помощью systemctl.
  
  Основные команды systemctl:
    • systemctl list-units --type service --all 	— просмотр всех юнитов в системе
    • systemctl start <name>    		— запустить сервис
    • systemctl stop <name>    			— остановить сервис
    • systemctl restart <name>    		— перезапустить сервис
    • systemctl status <name> 			— посмотреть статус сервиса
    • systemctl reload <name>    		— перечитать конфигурацию
    • systemctl daemon-reload   		— перечитать конфигурацию для всех
    • systemctl try-restart <name>    	— перезапустить, если запущен
    • systemctl enable <name>    		— включить автозапуск сервиса
    • systemctl disable <name>    		— отключить автозапуск сервиса
    • systemctl list-unit-files --type service 		— список установленных юнит-файлов сервисов


Практический пример:
  Юнит-файл сервиса cron
  1. $ cd /etc/systemd/system/
  (содержимое):
  default.target.wants
  getty.target.wants
  graphical.target.wants 
  local-fs.target.wants
  multi-user.target.wants
  network-online.target.wants
  ...и т.д.
  # множество директорий targets
  # Юниты сгруппированы по разным стадиям загрузки
  # cron.service лежит в /etc/systemd/system/multi-user.target.wants
  
<Содержимое файла>:
[Unit]
Description=Regular background program processing daemon	# краткое описание
Documentation=man:cron(8)									# ссылка на документацию
After=remote-fs.target nss-user-lookup.target

[Service]
EnvironmentFile=-/etc/default/cron			# cron использует отдельный файл с переменными окружения
ExecStart=/usr/sbin/cron -f $EXTRA_OPTS
IgnoreSIGPIPE=false
KillMode=process
Restart=on-failure							# перезапуск при падении

[Install]
WantedBy=multi-user.target

Примеры настроек в файлах конфигурации сервисов:
  • Restart — указывает, когда приложению надо перезагрузиться, а когда стоит продолжать лежать
			  (например, подняться в случае падения, но не перезапуска системы).
  • Documentation — ссылка на документацию.
  • EnvironmentFile — путь к файлу с переменными.

‼ Подробная информация про все директивы: $ man systemd.unit


  Получим информацию о переменных процесса cron:
	$ pidof cron
	> 867
	$ cat /proc/867/environ
	> LANG=en_US.UTF-8PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binINVOCATION_ID=0e51b140090f4edab9d4b95aebf6af28JOURNAL_STREAM=9:16304

# ‼ Все юниты systemd пишут логи в системный журнал. Их можно вызвать с помощью утилиты journalctl.

► вызов последних логов сервиса cron:
	$ sudo journalctl -u cron.service -e

► Посмотреть последние <NUM> записей в системном журнале логов для cron.service:
	$ journalctl -u cron.service -n <NUM>

► Посмотреть логи за определённый промежуток времени:
	$ sudo journalctl -u cron.service --since "2021-07-30 14:10:10" --until "2021-08-02 12:05:50" 


Кое-что полезное
  history показывает историю команд, запущенных под текущим юзером используемая для облочки bash.
  ! Можно запустить команду из истории ещё раз, используя её номер:
  $ history
	...
	581  pidof cron
	582  kill 867
	583  pidof cron
	584  systemctl status cron
	585  systemctl start cron
	586  systemctl status cron
	587  pidof cron
	588  history
	$ !587
	pidof cron
	23420

  ► kill посылает процессу сигнал завершения.
    Существуют разные типы сигналов завершения.
	Без аргументов kill посылает процессу SIGTERM.
	
  # Ознакомиться со всеми типами сигналов можно через запуск
    $ man 7 signal
