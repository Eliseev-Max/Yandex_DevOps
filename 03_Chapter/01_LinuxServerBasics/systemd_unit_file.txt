Руководство по написанию systemd Unit файлов
(main: https://manpages.debian.org/buster/systemd/systemd.exec.5.en.html)
(Using environment variables in systemd units: https://www.flatcar.org/docs/latest/setup/systemd/environment-variables/)
(Пишем systemd Unit файл: https://linux-notes.org/pishem-systemd-unit-fajl/)

Units — это объекты, которыми может управлять система
        (В основном — стандартизированное представление системных ресурсов, которыми может управлять набор демонов).

Файл конфигурации unit'а содержит информацию о:
  • службе,
  • сокете,
  • устройстве,
  • точке монтирования,
  • точке автомонтирования,
  • файле или разделе подкачки,
  • цели запуска (start-up target),
  • пути просматриваемой файловой системы,
  • таймере, управляемом и контролируемом systemd(1),
  • фрагменте управления ресурсами 
  • или группе созданных извне процессов.
  
Общие параметры конфигурации всех типов устройств должны быть настроены в разделах [Unit] или [Install] unit-файлов.
В дополнение к общим разделам [Unit] и [Install], каждый юнит может иметь раздел, специфичный для конкретного типа,
например, [Service] для юнита обслуживания. 

Дополнительные сведения (man-страницы):
  - systemd.service(5),
  - systemd.socket(5),
  - systemd.device(5),
  - systemd.mount(5),
  - systemd.automount(5),
  - systemd.swap(5),
  - systemd.target(5),
  - systemd.path(5),
  - systemd.timer(5),
  - systemd.slice(5),
  - systemd.scope(5).
  

Некоторые функции, которые легко реализовать:

  • Активация на основе сокетов:
    - Сокеты, связанные с сервисом, лучше всего вырываются из самого демона, чтобы обрабатываться отдельно.
	Преимущества: 
	  * задержка запуска службы до тех пор, пока соответствующий сокет не будет доступен.
	  * возможность системы создавать все сокеты до начала запуска процесса → можно параллельно загружать связанные службы.
	  
  • Активация на основе шины:
    - Unit-ы также могут быть активированы на интерфейсе шины, предоставляемом D-Bus-ом.
	  Устройство может быть запущено когда соответствующая шина доступна.
	  
  • Активация на основе пути:
    - Unit может быть запущен на основе активности или наличия определенных путей к файловой системе.
	  Это использует inotify.
	  
  • Активация на основе устройства:
    - Unit-ы также могут быть запущены при первой доступности (подключении) связанного оборудования за счет использования событий udev.
	
  • Неявное сопоставление зависимостей:
    - Большая часть структуры зависимостей для юнитов может быть построена самой системой.
	  Вы всё равно можете добавить информацию о зависимостях, но большая часть тяжелой работы будет решена за вас.
	  
  • Экземпляры и шаблоны:
    - Файлы блока шаблонов могут использоваться для создания нескольких экземпляров одного и того же общего устройства.
	  Это позволяет создавать небольшие вариации или единичные unit-ы, которые обеспечивают одну и ту же общую функцию.
	  
  • Простое упрощение безопасности:
    - Юниты могут реализовать некоторые довольно хорошие функции безопасности, добавив простые директивы.
	  Например:
	    * можно указать, какой доступ можно использовать (чтение, запись) при работе с файловой системой,
		* ограничить возможности ядра,
		* установить приватный /tmp фолдер и сетевой доступ.
		
  • Drop-ins и snippets:
    - Units можно легко расширить, предоставив фрагменты, которые будут отменять части файла системы.
	  Это позволяет легко переключаться между vanilla и индивидуальными реализациями.

Типы systemd unit файлов
  (Самый простой способ определить тип устройства — это посмотреть на его суффикс, который добавляется к концу имени юнита)

  * .service: 
    - Данный юнит описывает, как управлять службой или приложением на сервере.
	  Включает в себя:
	    • запуск или остановку службы,
		• при каких обстоятельствах она должна автоматически запускаться,
		• информацию о зависимости для соответствующего программного обеспечения.
		
  * .socket:
    - Файл сокет-устройства описывает сетевой, IPC-сокет или FIFO буфер, который systemd использует для активации сокета.
	  Они всегда имеют связанный .service файл, который будет запущен при сокет активности, которая определяет этот блок.
	  
  * .device:
    - Юнит, который описывает устройство, которое было указано как необходимое для управления systemd с помощью udev или файловой системы sysfs.
	  Не все устройства имеют файлы .device.
	  Некоторые скрипты, которым может потребоваться устройства .device, предназначены для монтирования и доступа к устройствам.
	  
  * .mount:
    - Этот блок определяет точку монтирования в системе, которой управляет systemd.
	  Они называются по пути монтирования, при этом «/» изменены на тире. Записи внутри /etc/fstab могут иметь блоки, созданные автоматически.
	  
  * .automount:
    - Модуль .automount настраивает точку монтирования, которая будет автоматически установлена
	  → должен быть определен после точки монтирования, на которую они ссылаются, 
	  → должны иметь соответствующий модуль .mount для определения особенностей монтирования.
  
  * .swap:
    - Данный юнит описывает SWAP (пространство подкачки) в системе.
	  Название этих блоков должно отражать путь к устройству или файлу.
  
  * .target:
    - Данный юнит используется для обеспечения точек синхронизации для других устройств при загрузке или изменения состояний.
	  Они также могут использоваться для перевода системы в новое состояние.
  
  * .path:
    - Данный юнит, определяет путь, который может использоваться для активации на основе пути.
	  По умолчанию, юнит будет запущен с тем же базовым именем.
	  Это использует inotify для отслеживания изменения путей.
  
  * .timer:
    - Этот юнит определяет таймер, который будет управляться systemd (аналог cron джоб) для задержки или запланированной активации.
	  При достижении таймера будет запускаться соответствующий блок.
  
  * .snapshot:
    - Это юнит создается автоматически командой snapshot systemctl.
	  Он позволяет вам восстановить текущее состояние системы после внесения изменений.
	  Снимки не сохраняются во время сеансов и используются для отката временных состояний.
  
  * .slice:
    - Он связан с узлами группы управления Linux, что позволяет ограничить ресурсы или назначить их для любых процессов, связанных с slice.
	  Имя отражает его иерархическую позицию внутри дерева групп.
	  Юниты размещаются в определенных slice по умолчанию в зависимости от их типа.
  
  * .scope:
    - Они создаются автоматически systemd из информации которую получили от его интерфейса шины.
	  Они используются для управления наборами системных процессов, созданных извне.


Логирование и стандартынй ввод/вывод (LOGGING AND STANDARD INPUT/OUTPUT):

  Параметры, относящиеся к разделу:
  * StandardInput=
  * StandardOutput=
  * StandardError=
  * StandardInputText=, StandardInputData=
  * LogLevelMax=
  * LogExtraFields=
  ** e t.c.

  Подробнее про StandardOutput=

  Управляет тем, куда подключается дескриптор файла 1 (STDOUT) выполняемых процессов.
  Принимает одно из значений:
    inherit,
    null,
    tty,
    journal,
    syslog,
    kmsg,
    journal+console,
    syslog+console,
    kmsg+console,
    file:path,
    append:path,
    socket
     или fd:name.

  inherit (унаследовать):
    - дублирует дескриптор файла стандартного ввода для стандартного вывода;

  null:
    - подключает стандартный вывод к /dev/null, т.е. все, что на него записано, будет потеряно.

  tty:
    - подключает стандартный вывод к tty (как настроено через TTYPath=, см. ниже).
    Если TTY используется только для вывода, выполняемый процесс не станет управляющим процессом терминала, не будет выходить из строя или ждать, пока другие процессы освободят терминал.

    
  journal:
    - соединяет стандартный вывод с журналом, который доступен через journalctl(1).
    Обратите внимание, что все, что записывается в syslog или kmsg (см. ниже), неявно сохраняется и в журнале,
    поэтому конкретные две опции, перечисленные ниже, являются дополнениями этой.
    
  syslog:
    - подключает стандартный вывод к системной службе syslog(3), в дополнение к журналу.
    Обратите внимание, что демон журнала обычно настроен на пересылку всего, что он получает, в syslog в любом случае,
    и в этом случае эта опция ничем не отличается от journal.
    
  kmsg:
    - соединяет стандартный вывод с буфером журнала ядра, который доступен через dmesg(1), в дополнение к журналу.
    Демон журнала может быть настроен на отправку всех журналов в kmsg в любом случае,
    в этом случае эта опция не отличается от journal.
    
  journal+console, syslog+console и kmsg+console работают так же, как и три вышеуказанные опции,
  !! но копируют вывод на системную консоль.
    
  file:<path>
    - Опция file:path может быть использована для подключения определенного объекта файловой системы к стандартному выводу.
    Семантика схожа с аналогичной опцией StandardInput=.
    Если путь ссылается на обычный файл в файловой системе, то он открывается (создается, если еще не существует) для записи в начале файла, но без его усечения.
    Если стандартный ввод и вывод направлены на один и тот же путь к файлу, он открывается только один раз, как для чтения, так и для записи, и дублируется.
    Это особенно полезно, когда указанный путь ссылается на сокет AF_UNIX в файловой системе, поскольку в этом случае создается только одно потоковое соединение как для ввода, так и для вывода.
    
    append:<path>
      - аналогичен file:path, но открывает файл в режиме добавления.
    
    socket

# Директива Environment
  В systemd есть директива Environment, которая устанавливает переменные окружения для выполняемых процессов.
  Она принимает список назначений переменных, разделенных пробелами.
  Этот параметр может быть указан более одного раза, в этом случае будут установлены все перечисленные переменные.
  → Если одна и та же переменная задана дважды, более поздняя установка отменяет более раннюю.
  → Если этой опции присвоена пустая строка, список переменных окружения обнуляется, все предыдущие назначения не имеют эффекта.

# Директива EnvironmentFile
  EnvironmentFile аналогична директиве Environment, но считывает переменные окружения из текстового файла.
  Текстовый файл должен содержать назначения переменных, разделенных новыми строками.
  
  Например, в Flatcar Container Linux служба coreos-metadata.service создает /run/metadata/coreos.
  Этот файл окружения может быть включен другими службами для внесения динамической конфигурации.
  
  Вот пример файла окружения при запуске на DigitalOcean (IP-адреса удалены):
  # /run/metadata/coreos
    COREOS_DIGITALOCEAN_IPV4_ANCHOR_0=X.X.X.X
    COREOS_DIGITALOCEAN_IPV4_PRIVATE_0=X.X.X.X
    COREOS_DIGITALOCEAN_HOSTNAME=test.example.com
    COREOS_DIGITALOCEAN_IPV4_PUBLIC_0=X.X.X.X
    COREOS_DIGITALOCEAN_IPV6_PUBLIC_0=X:X:X:X:X:X:X:X

Затем этот файл окружения может быть использован и его переменные могут быть использованы.
Вот пример вставки для etcd-member.service, которая запускает coreos-metadata.service и затем использует сгенерированные результаты:

[Unit]
Requires=coreos-metadata.service
After=coreos-metadata.service

[Service]
EnvironmentFile=/run/metadata/coreos
ExecStart=
ExecStart=/usr/bin/etcd2 \
  --advertise-client-urls=http://${COREOS_DIGITALOCEAN_IPV4_PUBLIC_0}:2379 \
  --initial-advertise-peer-urls=http://${COREOS_DIGITALOCEAN_IPV4_PRIVATE_0}:2380 \
  --listen-client-urls=http://0.0.0.0:2379 \
  --listen-peer-urls=http://${COREOS_DIGITALOCEAN_IPV4_PRIVATE_0}:2380 \
  --initial-cluster=%m=http://${COREOS_DIGITALOCEAN_IPV4_PRIVATE_0}:2380
