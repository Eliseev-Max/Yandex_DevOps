
Из этого урока вы научитесь:
  -> просматривать принадлежность файлов.
  -> выдавать права на файлы.
  -> выяснять, кто сейчас использует конкретный файл.
  -> управлять использованием ресурсов дисковой системы.


процесс обращается к дескриптору -> файл находится в статусе «используется» -> не получится удалить файл.
Понадобится перезапустить процесс и только тогда произойдёт чистка.

Чтобы пользователь user смог получить доступ к файлам,владельцем которых является другой пользователь,
есть несколько решений:
  -> Поменять владельца файлов.
  -> Поменять права на файлы.
  -> Поменять пользователя, с правами которого работает user.

Смена владельца файла:
  $ sudo chown пользователь:группа путь/к/файлу
  # chown == change owner

  $ sudo chown -R  - рекурсивная замена прав файлов (поменять права сразу на все вложенные файлы и папки)

(man df: https://www.opennet.ru/man.shtml?topic=df&category=1&russian=0)


Узнать, сколько места занимает папка на диске (disk usage):
  $ du
    -h — форматирование в человеко-читаемом формате
    -d N — глубина поиска (уровень погружения в каталоги)

Использование du:
  $ du -h -d 10 /var/log | sort -rh
  # список директорий с их размерами в убывающем порядке
  # если некоторые данные недоступны, чтобы увидеть объём занятого пространства, надо вызвать команду с привилегиями суперадминистратора

(man du: https://www.opennet.ru/man.shtml?topic=du&category=1&russian=0)


Для более удобного анализа дискового пространства существует утилита ncdu
  + она имеет интерактивный псевдографический интерфейс

  Просканировать и вывести данные о конкретной директории (например, /var/log):
    $ ncdu /var/log

  Количество символов # помогает визуально определить, какие файлы и каталоги занимают больше всего места.
  Первый столбец может содержать дополнительную информацию, например:
    ! — ошибка при чтении директории
    . — ошибка при чтении поддиректории, то есть указанный размер подсчитан без учёта этой директории
    e — пустая директория
    H — объект уже был учтён (жёсткая ссылка)

(ncdu documentation: https://dev.yorhel.nl/ncdu/man)

Подсчёт истинного размера директории может быть неверным: -> в поддиректории могут быть точки монтирования.
Исключить точки монтирования из анализа: добавить параметр -x.


Утилита lsof
  - выводит список открытых файлов, сокетов и каналов
  [без параметров]: ->  список всех открытых файлов для текущих активных процессов
  [запущена простым пользователем]: -> выдает информацию только
   о процессах, запущенных этим пользователем

  Пример:

  $ lsof
COMMAND     PID   TID TASKCMD         USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
init          1                       root  cwd       DIR              254,0       241         96 /
init          1                       root  rtd       DIR              254,0       241         96 /
init          1                       root  txt       REG              254,0     52800   67750339 /sbin/init
init          1                       root  mem       REG              254,0   1818704   67742326 /lib64/libc-2.33.so
init          1                       root  mem       REG              254,0    202144   67742344 /lib64/ld-2.33.so
init          1                       root   10u     FIFO               0,21       0t0        400 /run/initctl

  COMMAND — процесс (команда), которая использует файл
  PID — идентификатор процесса
  USER — владелец процесса
  FD — дескриптор файла:
    • cwd — текущая рабочая директория;
	• ltx - текст разделяемой библиотеки;
    • rtd — директория root;
    • txt — (исполняемый файл) текст программы (код и данные);
    • mem — область памяти (файл, загруженный в память, memory-mapped file);
    • число — это номер дескриптора файла, используемого процессом
	  - сопровождается символом:
      * u — файл открыт с правами на чтение и запись;
      * r — файл открыт с правами на чтение;
      * w — файл открыт с правами на запись с частичной блокировкой файла;
	Символ блокировки может быть одним из:
      r: Блокировка чтения на часть файла.
      R: Блокировка чтения на весь файл.
      w: Блокировка записи на часть файла.
      W: Блокировка записи на весь файл (открыт с правами на запись).
      u: Блокировка чтения и записи любой длины.
      U: неизвестный тип блокировки.
       : [символ пробела]. Нет блокировки.

  TYPE — тип файла:
    • REG — файл
    • DIR — директория
	• BLK - файл блочного устройства
	• CHR - файл символьного устройства
	• LINK - файл символической ссылки
	• INET - Internet-сокет
	• UNIX - доменный сокет UNIX
    • FIFO — именованные каналы

  DEVICE — номер устройства, на котором находится файл
  SIZE/OFF — размер
  NODE — номер inode, индексного дескриптора
  NAME — имя файла


  $ lsof +D /tmp/test			# $vi /tmp/test/test.txt  + Ctrl+z == bg process
  # искать все открытые экземпляры каталога /tmp/test и все содержащиеся в нем файлы и каталоги на всю его глубину
  
>> Более подробная информация о процессе:
    $ lsof -p <PID>

# ! Редактор vi использует файлы типа: .filename.swp для хранения временной версии файла
# Удалим файл /tmp/test/.test.txt.swp 
# А затем запустим lsof:

$ lsof | grep deleted | grep test.txt.swp
vim        30151                      makky    6u      REG              254,0     12288   3058807 /tmp/test/.test.txt.swp (deleted)

Файл всё ещё находится на месте, поскольку используется процессом vi
Если закрыть редактор vi (предварительно вернув его из фонового режима: fg), 
файл исчезает окончательно, потому что файловый дескриптор из /proc уничтожается вместе с процессом.

  $ lsof -a +L1 /tmp/test
  # покажет только удалённые файлы в конкретной директории,
  # которые занимают память из-за того, что процесс не отпустил дескрипторы.

(man lsof: https://linux.die.net/man/8/lsof)


Дисковая система

 Типы файлов: (-> [ls -l])
    -  Обычный файл.
    d  Директория — это объект файловой системы, который упрощает работу с файлами, позволяя группировать их.
    l  Символическая cсылка.
    b  Файл блочного устройства.
    c  Файл символьного устройства.
    p  Именованные каналы.
    s  Сокет.
    n  Сетевой файл.

  Символические ссылки:
    $ ln -s <flie> <link>
	# размер ссылки = количество символов в пути до файла
	# если удалить file, ссылка будет вести в никуда
	
	
#	
# Различия жёсткой и символической ссылок:
#  Жёсткая ссылка
#	* inode файла = inode ссылки
#	* не может быть создана для файла в другой файловой системе
#   * не может вести на директорию
#	* при удалении файла продолжает указывать на блоки данных
#	
#	<Создаётся>:    $ ln file file_h
#	
#	Счётчик ссылок хранит информацию о количестве жёстких ссылок
#   Поиск по inode файла с несколькими жёсткими ссылками выдаст файл + все жёсткие ссылки:
	  $ find . -inum <inode>
	> /file
	> /hard_link1
	> /hard_link2
	...
	> /hard_linkN
#	Размер жёсткой ссылки = размер файла, на который она указывает
#	Жёсткая ссылка = аналог файла
#	
#  Символическая ссылка
#	* размер равен количеству байт в пути, который задан при создании ссылки
#	* при удалении файла указывает в никуда
#	
#	<Создаётся>:    $ ln -s file file_s
#	
#	Размер символической ссылки = размеру пути до файла
# 
#  Если создать символическую ссылку, а затем передвинуть оригинальный файл в другую папку,
#  то получить содержимое файла из ссылки НЕЛЬЗЯ
#
#  Если создать жёсткую ссылку, а затем передвинуть оригинальный файл в другую папку,
#  то получить содержимое файла из ссылки МОЖНО
#

  Каждый файл в файловых системах имеет индексный дескриптор (inode, инод).
  Иноды — это мета-данные, которые содержат информацию о файле:
    * владелец
    * права
    * размер
    * время последней модификации
    * время создания
    * группа
    * местонахождение файла
  ‼ имени файла inode НЕ содержат.
  
  Посмотреть информацию из иноды: утилита stat
  
  Статистика использования инод:  $ df -i
  Inodes | IUsed | IFree | IUse%
  
  В файловых системах extX количество инод статическое, поэтому при большом скоплении файлов на диске, иноды могут закончиться
  В файловых системах xfs, jfs, btrfs иноды выделяются динамически, и потребность в ручном изменении количества пропадает

ВЫВОД:
  файл - это жёсткая ссылка на inode.
  Создавая файл, система выделяет под него:
    • область на диске,
	• иноду,
	• ссылку на иноду.

  Создавая жёсткую ссылку, система создаёт ссылку на иноду.


Именованные и неименованные каналы

  pipe ( | ) - перенаправляет вывод одной команды в другую.
  Каналы (pipe) перенаправляют вывод, ввод или ошибку от одного процесса к другому через буфер.
  
  Чаще всего встречается неименованный канал (|).
  Пример:
    1. взять имена всех файлов и папок из текущего каталога,
	2. перенаправить результат команды ls в фильтр по слову file и 
	3. удалить из полученного списка все элементы с ssh:
	
	  $ ls | grep file | grep -v ssh
	
	‼* После выполнения своей задачи неименованный канал удаляется.

  Именованные каналы:
    - могут работать до перезагрузки виртуалки или пока канал не будет удалён;
	- внутри именованных каналов заложен механизм FIFO (First In First Out, т.е. первый пришел — первый вышел),
	    и так как в Linux за всё это отвечает файл, поэтому и канал не является исключением.
    - создаётся командой  mkfifo  или  mknod -p
	- отображается в Linux, как файл с типом 'p' и размером 0
	
  ‼ в отличие от неименованного канала, перенаправление вывода других команд не завершится!
  * надо будет выполнить прерывание Ctrl+c

############
#  Пример: #
############
$ mknod test_pipe p
$ cat file1 > test_pipe
Ctrl+c
$ ls -l test_pipe
prw-rw-----  1  root  root  0  Sep  23  12:51  test_pipe


Дополнительные возможности стандартных прав доступа
  ► SUID
  ► SGID
  ► Sticky bit

Смена идентификатора (SUID)
    - позволяет запустить процесс непривилегированному пользователю с правами владельца файла.

  # Утилита chmod изменяет биты режима файла каждого данного файла в соответствии с режимом mode,
  #  который может быть:
    - символическим представлением изменений, которые нужно сделать, 
	- восьмеричным числом, представляющим битовую схему для новых битов режима.

  # Формат символьного режима - [ugoa...][[+-=][perms...]...]
  # u (user) = пользователь-владелец;
  # g (group) = другие пользователи из группы файла
  # o (other) = другие пользователи, не входящие в группу файла;
  # a (all) =  все пользователи
  
  # оператор +  = добавляет выбранные биты режима файла к существующим битам режима файла каждого файла
  # оператор -  = удаляет выбранные биты режима файла к существующим битам режима файла каждого файла
  
  # perms - это либо ноль или более букв из набора rwxXst, либо одна буква из набора ugo
  # Буквы rwxXst выбирают биты режима файла для затронутых пользователей:
  #  * r = чтение
  #  * w = запись
  #  * x = выполнение (/поиск в каталогах)
  #  * X = выполнение/поиск только если файл является каталогом или уже имеет разрешение на выполнение для некоторого пользователя
  #  * s = установка идентификатора пользователя или группы при выполнении
  #  * t = ограниченный флаг удаления или "липкий бит" (sticky bit)
  
 # Пример: скопируем программу id в домашнюю директорию и попробуем назначить SUID

	$ mkdir -p /tmp/test3 && cd /tmp/test3
    $ cp /usr/bin/id .
    $ sudo chown root.makky ./id
    $ sudo chmod u+s,a+rx id			# числовой аналог 4555
#### пользователю-владельцу (u) добавить бит режима s (установить идентификатор пользователя при выполнении)
#### всем пользователям (a) добавить биты режимов чтения (r) и выполнения (x)	
    $ ls -la id
    -rwsr-xr-x 1 root makky 43560 Jun  7 13:26 id
	
	$ ./id
    uid=1000(makky) gid=1001(makky) euid=0(root) groups=1001(makky),10(wheel),48(docker),304(vboxusers),443(sudo)
	
  # У нас появился euid.
  # EUID — это эффективный идентификатор пользователя,
  # он изменяется для процессов (не для пользователя) с битом setuid, которые выполняет пользователь.
  
  Если вызвать основную команду id, а не пропатченную нами, то никакого euid не будет:
    $ id
    uid=1000(makky) gid=1001(makky) groups=1001(makky),10(wheel),48(docker),304(vboxusers),443(sudo)  # euid нет. Не назначен SUID

  Помимо euid существует понятие ruid
  RUID — это настоящий идентификатор пользователя, который не меняется.
  Пользователь входит в систему -> оболочка запускается с его реальным идентификатором ->
      -> все процессы, запускающиеся из оболочки, наследуют реальный идентификатор.

{?? Как работает passwd ??}:
  У passwd установлен setuid bit:
    $ ls -la /bin/passwd
    -rws--x--x 1 root root 60384 May 16 01:28 /bin/passwd
	
  # Когда пользователь меняет свой пароль командой /usr/bin/passwd:
    ► RUID пользователя остаётся прежним;
	► EUID станет root
	Таким образом, процесс passwd может произвести запись в файлы
	• /etc/passwd
	  и
	• /etc/shadow
  Также passwd проверяет ruid пользователя, иначе вы могли бы поменять пароль любого пользователя в системе без каких-либо прав.
  

Смена группового идентификатора (SGID)
  SGID аналогичен SUID,
  ! но устанавливаются права группы владельца файла.
  
  Если SGID назначен директории, то создаваемые в директории объекты получат идентификатор группы владельца.
  Т.е. новые файлы и директории, создаваемые в директории с установленным SGID, будут наследовать права от директории-родителя.
  
  Пример:
  $ mkdir -p /tmp/test4 && cd /tmp/test4
  $ cp /usr/bin/id .
  $ chmod g+s,a+rx id		# числовой аналог - 2555
  $ ls -la id
  -rwxr-sr-x 1 makky makky 43560 Jun  7 13:26 id
  
  $ ./id
  uid=1000(makky) gid=1001(makky) egid=0(root) groups=0(root),10(wheel),48(docker),304(vboxusers),443(sudo),1001(makky)
  
  Аналогично SUID появился egid (Effective Group ID).
  То есть процесс выполнится с правами текущего пользователя и группой владельца

Пример из жизни:

$ cp /usr/bin/touch .
$ ls -la touch
-rwxr-xr-x 1 makky makky 96936 Sep 19 14:02 touch
$ sudo chown root.root touch
$ sudo chmod g+s,a+rx touch
$ ls -la touch
-rwxr-sr-x 1 root root 96936 Sep 19 14:02 touch
$ ./touch 123
$ ls -la 123
-rw-r--r-- 1 makky root 0 Sep 19 14:02 123
####
В примере мы
  1. поменяли gid для копии команды touch 
  2. создали с помощью неё файл.
  
  Новый файл создался с правами текущего пользователя и группой владельца процесса.

‼ Если в правах мы видим S, это значит, что
  • setuid/setgid bit включён, 
  • но eXecute не разрешён.
Так как suid/sgid перекрывают X, то такой набор прав не имеет смысла.


Sticky Bit
  Sticky bit запрещает удаление файла при наличии достаточных прав, если вы не его владелец.
  ‼ Это правило не распространяется для root.
  
  Типичный пример использования /tmp или /var/tmp
  Назначается sticky bit chmod +t или в числовом выражении 1777:
    $ chmod +t [path_to_directory]
	
  Как определить Sticky Bit?
    - Sticky bit выглядит как буква t в конце первой колонки вывода ls -l.
	Если не задан eXecution bit для всех (others), то будет T


Access List (acl)

  Каждый файл в любой файловой системе будет иметь владельца, группу и права.
  Когда нескольким пользователям нужен доступ к одному и тому же файлу, а принадлежат они к разным группам,
  нам помогут расширенные права доступа или Access List (acl).
  
  Проверим, что поддержка acl включена.
  -> ищем во всех файлах  /boot/config  строку с конфигурацией ACL:
    $ cat /boot/config* | grep _ACL
	CONFIG_EXT4_FS_POSIX_ACL=y
	---
    ...для уменьшения размера листинга вырезаны однотипные записи ...
	---
    CONFIG_CIFS_ACL=y

  ‼ Если знак + есть в списке прав, это значит, что у файла есть расширенные права.
  
  $ ls -l
  total 0
  -rw-rw-r--+ 1 makky makky 0 Jun  7 10:30 1
  -rw-r--r--  1 makky makky 0 Jun  7 10:30 2
  -rw-r--r--  1 makky makky 0 Jun  7 10:30 3
  
  getfacl - просмотр дополнительных разрешений
  
$ getfacl file1
# file: file1
# owner: makky
# group: makky
user::rw-
group::r--
group:makky:rw-		# расширенные права
group:max:rw-		# расширенные права
mask::rw-			# mask -  спец. возможность, ограничивающая максимально возможные права доступа
other::r--

  ‼! Нельзя назначать права rwx для others!


Назначим расширенные права на файл file1:

$ mkdir -p /tmp/test5 && touch /tmp/test5/file1
$ setfacl -m u:max:rw /tmp/test5/file1 # пользователь, который используется в этой команде, уже должен быть в системе

Опция -m заставляет команду setfacl модифицировать права на файл:
  $ setfacl -m g:max:rw /tmp/test5/file1

Можно назначить сразу много прав одной командой:
  $ setfacl -m u:max:rw,g:makky:rwx /tmp/test5/file1 


Права по умолчанию для новых файлов

Назначим права RW по умолчанию для вновь создаваемых файлов в директории для пользователя max:
$ sudo mkdir /tmp/data
$ sudo setfacl -m default:u:max:rw /tmp/data
$ sudo getfacl /tmp/data
# file: /tmp/data
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
default:user::rwx
default:user:max:rw-		# запись появилась после выполнения команды
default:group::r-x
default:mask::rwx
default:other::r-x

> В default появилась запись default:user:max:rw-

Теперь создадим файл и проверим его расширенные права:

$ sudo touch /tmp/data/test
$ sudo getfacl /tmp/data/test
getfacl: Removing leading '/' from absolute path names
# file: tmp/data/test
# owner: root
# group: root
user::rw-
user:max:rw-		# унаследовалось
group::r-x
mask::rw-
other::r-- 

сохранить разветвлённую систему расширенных прав:

$ cd /tmp/data
$ sudo getfacl -R * > /tmp/accounts_facl 

 [-x] - удаление расширенных прав
   $ sudo setfacl -x u:max /tmp/data/test
   
 [-b] - удаление всех расширенных прав
   $ sudo setfacl -b u:max /tmp/data/test
   
Результат:

$ sudo getfacl /tmp/data/test
getfacl: Removing leading '/' from absolute path names
# file: tmp/data/test
# owner: root
# group: root
user::rw-
group::r-x
other::r--

! Восстановить удалённые права:
  $ setfacl --restore=/tmp/accounts_facl
  
  