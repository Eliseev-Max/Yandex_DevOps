# sources:
# Static Application Security Testing (SAST):
# https://docs.gitlab.com/ee/user/application_security/sast/

Повестка урока:
    • Стандарты кода и автоматизация борьбы за хороший код.
    • Возможности SonarQube.
    • Взаимодействия GitLab и SonarQube.
    • Различные инструменты обработки кода в действии.


Стандарты кода и автоматизация борьбы за хороший код

	Стандарт оформления кода (стиль программирования)
      • существует для каждого языка программирования;
	  • обычно содержит набор правил и соглашений (например, как называть переменные), используемых при написании кода 
	  → позволяет облегчить чтение (понимание) и поддержку кода, над которым работают несколько человек. 
	  
	Примеры:
	  ♦ PEP-8 - для Python
	  ♦ Code Conventions for Java Programming Language - для Java
	
	Пример соглашений, составленных НЕ создателями языка:
	  ○ MISRA C
	  ○ Google C++ Style Guide
	
	Проверка кода на соответствие соглашениям производится
	  • персонально, в IDE разработчика
	  • централизованно на репозиторий, где хранится код
	    •• производить проверку средствами репозитория;
		   (Gitlab, Github)
		•• производить проверку с помощью подключаемых сторонних сервисов, которые специализируются на проверках кода
		   (SonarQube, Codacy)
	
	► код будет автоматически проходить проверки во время очередной фиксации кода (commit);
	► в случае «завала» проверок — выполняться какой-либо сценарий, например, запрет на мёрж кода.
	
	
Проверка кода на уязвимости.
  Для этих целей можно использовать те же самые средства, что и для проверки качества кода, чаще всего просто добавляя модули.
  Подходы при проверке кода на безопасность:
    
	• SAST
	• DAST
	• IAST
	• RASP
	
  SAST (Static Application Security Testing — статическое тестирование безопасности приложения) — тестирование «белого ящика».
	Это анализ кода на соответствие стандартам и возможное наличие уязвимостей без запуска исследуемого приложения на исполнение.
	Проверки SAST подключаются на ранних этапах разработки ПО и позволяют подсвечивать проблемы с кодом ещё до того момента, как приложение будет запущено.
	
	Особенности применения SAST:
	  ○ требует доступ к коду приложения;
      + не требует запуска приложения;
      + раннее обнаружение ошибок позволяет легче их устранять;
      - возможны ложные срабатывания.

  DAST (Dynamic Application Security Testing — динамическое тестирование безопасности приложения) — тестирование «чёрного ящика».
    Это поиск распространённых уязвимостей и слабых мест в работающем приложении до того, как это сделали злоумышленники.
	Иными словами, это имитация атаки на систему.
	Такой анализ:
	  - не подразумевает доступ к исходному коду,
	  - производится за счёт использования методов внедрения ошибок в приложения, таких как передача некорректных или вредоносных данных в программное обеспечение (например,SQL-инъекции).

	Особенности применения DAST:
	  ○ требует работающее приложение
      + не требует доступ к коду или бинарникам
      - не покажет, где именно в коде ошибка
      - занимает больше времени, по сравнению с SAST
      + обнаруживает проблемы времени выполнения (например, аутентификации, конфигурации сервера)

  IAST (Interactive Application Security Testing — интерактивное тестирование безопасности приложения) — анализирует работу приложения изнутри.
    В рамках IAST устанавливаются агенты (датчики), которые непрерывно выполняют сбор и анализ данных о работе приложения во время его тестирования (ручное, автоматическое).
	Датчики могут иметь доступ к различным компонентам приложения:
	  • исходному коду,
	  • конфигурациям,
	  • потокам данных  и другим.
	Тестирование может выполняться в процессе сборки, тестирования или даже работы приложения в производственной среде.

	Особенности применения IAST:
	  + может указать проблемное место в коде
      + удобно интегрируется в CI/CD
      ○ влияет на работу приложения, так как тесно связан с ним


  RASP (Run-time Application Security Protection — тестирование безопасности приложения во время работы) — анализирует поведение приложения и контекст его выполнения.
    RASP сканирует и фиксирует запросы к приложению и анализирует их обработку внутри приложения.
	В случае обнаружения подозрительной активности может либо сообщить об инциденте, либо даже заблокировать угрозу.

	Особенности применения RASP:
	  - влияет на производительность приложения
      ○ не рекомендуется как единственное средство тестирования (без SAST, DAST и IAST)


Тестирование. Популярные тесты.
	
	Статический анализ — исследование кода анализатором, без сборки или запуска.
	  В простейшем случае проверяет правильность синтаксиса, соответствие стандарту кода для языка программирования.
	  Например, spotbugs для Java.

	Модульные (Unit) тесты — проверяют каждую отдельную функцию, метод, блок или класс кода.
	  Чаще всего unit-тесты пишут сами программисты: test-driven development (TDD) — до написания тестируемой функции, либо после.
	  
	Интеграционные тесты — проверка взаимодействия частей ПО, например, модулей из модульного тестирования или других модулей, которые объединяются ради большей функциональности.
	  Интеграционное тестирование следит, чтобы изменения в коде одного модуля не ломали другие.
	  Также здесь могут проверяться доступы между модулями или во внешние системы.
	  
	Тестирование интерфейса приложения (будь то Web UI или REST API) может производиться вручную и автоматически (например, Selenium).
	  Такие тесты чаще всего пишут тестировщики.
	  
	Smoke test (дымовое тестирование) — минимальный набор тестов на явные или грубые ошибки.
	  За названием стоят печники, которые после сборки агрегата закрывали все заглушки, а потом топили и смотрели, чтобы дым шёл только из правильных мест.

	UAT (User Acceptance Test) — приёмочное тестирование, которое проводят для проверки выполнения требований спецификации или контракта.
	  Может выполняться при участии заказчика при сдаче проекта или части функциональности проекта.

	Нагрузочное тестирование — направлено на определение и сбор показателей поведения ПО при высокой нагрузке.
	  Например, время отклика интерфейса ПО.
	  Нагрузочное тестирование поддерживает инструменты автоматизации, 
	  например:
	    • JMeter,
		• MZBench,
		• Locust
		...и другие.


<-= SonarQube =->
  - платформа с открытым исходным кодом для непрерывного анализа (continuous inspection) и измерения качества программного кода.
  
  Возможности SonarQube:

    1. Поддерживает анализ кода и поиск ошибок для большинства популярных языков программирования.
    2. Предоставляет отчёты об ошибках в коде, соблюдении стандартов кодирования, дублировании кода, уязвимости кода, технический долг* и другое.
    3. Поддерживает интеграцию с IDE (Visual Code, IntelliJ IDEA и другие).
    4. Поддерживает интеграцию с большинством репозиториев (GitLab, Bitbucket) и легко встраивается в пайплайны (Jenkins, GitLab).
    5. Сохраняет историю метрик и строит графики. Позволяет увидеть общую тенденцию изменения качества программного обеспечения в ходе разработки.
    6. Позволяет подключать плагины, расширяющие функциональность.

[* технический долг:
    одну и ту же задачу можно решить несколькими способами.
	Если выбрать неоптимальное решение или "наговнокодить", то возникает ситуация, которая в будущем создаст необходимость вернуться к этой
	части кода и оптимизировать/переписать её.
	Это называется техническим долгом.
]

  Анализ кода с помощью SonarQube происходит следующим образом: 

    1. Сканнеры (Analyzers) проверяют код в соответствии с тем, какой язык программирования используется на проекте. 
	   Затем отправляют информацию на сервер в базу данных.
    
	2. На сервере настроены правила (Rules), согласно которым анализируется информация о проверке проекта и собирается статистика по количеству уязвимостей разного типа
	  (○ Bug,
	   ○ Code Smell,
	   ○ Vulnerabilities 
	   .и другие).
	   ‼ Можно использовать как предустановленные правила, так и создавать свои, если стандартные правила не ловят баги, специфичные для вашего проекта.
    
	3. Правила сгруппированы по языкам программирования и могут объединяться в профили качества (Quality Profiles).
	   Профили качества можно использовать предустановленные, либо создавать свои, просто набирая в новый профиль нужные правила.
    
	4. К полученной от сканеров информации применяется профиль качества и, в соответствие с установленным уровнем качества (Quality Gates), SonarQube пытается дать ответ:
	   готов ли проект к релизу или нет?
	   Существует предустановленный уровень качества (Sonar way), но можно создавать и свои, если, например, вы хотите подвинуть вверх или вниз какой-либо из параметров кода.
    
	5. Взяв за основу выполненную работу, SonarQube может производить дополнительные действия, например,
	  → отправлять письмо
	  или
	  → выполнять webhook,
	  что добавляет возможностей для автоматизации.

  ‼ Чтобы ускорить пайплайны, можно настроить проверку только для нового кода и файлов, прибывших с пулл-реквестом или коммитом.
  
  * для анализа кода в GitLab, можно использовать возможности самого GitLab (GitLab Security Dashboards и Security Center).
  Они устанавливаются как плагины или берутся из коллекций GitLab Auto DevOps.
  
  Удобство последнего метода:
    подключение стандартных проверок может происходить добавлением пары строк в ваш gitlab-ci.yaml файл.
  
  Преимущество первых двух методов:
    возможность работать через UI.

  Коллекции GitLab Auto DevOps:
    • Auto Code Quality 
	• Auto SAST

  Схожие с SonarQube моменты при проверке кода встроенными средствами GitLab:
    ► также есть сканеры (Analyzers)
	► изменяемые правила (Rulesets)
	► найденные уязвимости группируются по степени риска от Unknown до Critical.
	
  Использование Gitlab SAST:
    + его интеграция в репозиторий и в процесс CI/CD

  Использование SonarQube:
    + красивый информативный интерфейс;
	+ аналитические возможности SonarQube (графики, история)
	
	
build-backend:  				# задача с именем build-code-job
  stage: build   				# этап build
  only: # запуск этого шага только при изменениях в директориях backend и frontend
    changes:
    - backend/*
  script:        				# объявление скрипта
    - cd backend
    - mvn -Dmaven.repo.local=${CI_PROJECT_DIR}/.m2/repository package
	  # при запуске сборке mvn передаешь параметр -Dmaven.repo.local:


у меня вот так выглядит и работает:

sonarqube-frontend-sast:
  stage: test
  image: sonarsource/sonar-scanner-cli:latest
  script:
    - cd frontend
    - sonar-scanner -Dsonar.projectKey=${SONAR_PROJECT_KEY_FRONT} -Dsonar.sources=. -Dsonar.host.url=${SONARQUBE_URL} -Dsonar.login=${SONAR_LOGIN_FRONT}
  needs:
    - build-frontend
	

########

# .gitlab-ci.yml

stages:
# - other_stages
  - triggers

trigger_backend:
  stage: triggers
  trigger:
    include: backend/.gitlab-ci.yml
  rules:
    - changes:
        - backend/*

trigger_frontend:
  stage: triggers
  trigger:
    include: frontend/.gitlab-ci.yml
  rules:
    - changes:
        - frontend/*

Практика SonarQube
	1. Авторизоваться в SonarQube, используя метод авторизации GitLab
	2. Add project → Manually		# создаём новый проект
	3. Ввести уникальное имя для проекта
	4. Дать имя для токена → [Generate] → (токен создан) → [Continue]
token:>  217045276f79c68a76800dea3ae3e018b94174b5
	5. Под вопросом: What option best describes your build?
	    для бэкенда   = Maven
	    для фронтенда = Other
	6. Полученную команду добавьте в пайплайн вашего .gitlab-ci.yml файла как новую задачу в стадии: test
	    Пример для бэкенда:
		
sonarqube-backend-sast:
  stage: test
  image: maven:3.8-openjdk-16 					# тот самый docker-образ, о котором мы все узнаем в будущем
  script:
    - cd backend
    - >
      mvn verify sonar:sonar -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=${SONAR_PROJECT_KEY}
      -Dsonar.host.url=${SONARQUBE_URL}
      -Dsonar.login=${SONAR_LOGIN}

	7. ‼ нужно запустить Maven лишь для фазы жизненного цикла Verify, 
  которая выполняет любые проверки, чтобы подтвердить пригодность пакета и соответствие критериям качества.
    # ‼ Поэтому вместо сгенерированного SonarQube скрипта "mvn sonar:sonar" мы используем:
	# mvn verify sonar:sonar -Dsonar.qualitygate.wait=true

	8. добавить флаг -Dsonar.qualitygate.wait=true, который заставит сканер ждать окончания результатов анализа
	   ! Каждый job в GitLab выполняется в окружении Docker-контейнера
	   ‼ Задать имя Docker-образа для этого job'а
	   # проект использует Java ver. 16 → image: maven:3.8-openjdk-16
	
	9. Все переменные, используемые в секции script, необходимо определить в секции CI/CD, в настройках проекта: Settings -> CI/CD

#### Если ошибки загнали проверку в тупик ####
	    Сбоит метод validateProductsExistence — это 74 строка файла backend/src/main/java/com/yandex/practicum/devops/controller/OrderController.java.
    Sonar подскажет, где найти нужное место в коде.
    А код здорового сервиса выглядит так:
##########################################################
if (!CollectionUtils.isEmpty(list)) {
throw new ResourceNotFoundException("Product not found");
}
##########################################################

Backend's YAML markup:

mvn sonar:sonar \
  -Dsonar.projectKey=Elisev-Max-Project \
  -Dsonar.host.url=https://sonarqube.praktikum-services.ru \
  -Dsonar.login=217045276f79c68a76800dea3ae3e018b94174b5

Frontend's YAML markup:

sonar-scanner \
  -Dsonar.projectKey=Elisev-Max-Project \
  -Dsonar.sources=. \
  -Dsonar.host.url=https://sonarqube.praktikum-services.ru \
  -Dsonar.login=217045276f79c68a76800dea3ae3e018b94174b5

###########################
# Пример SonarScanner CLI #
###########################

sonarqube-check:
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
    GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner -Dsonar.qualitygate.wait=true
  allow_failure: true
  rules:
    - if: $CI_COMMIT_REF_NAME == 'main' || $CI_PIPELINE_SOURCE == 'merge_request_event'

#########################################

Prepare jobs for .gitlab-ci.yml:

# backend:
sonarqube-backend-sast:
  stage: test
  image: maven:3.8-openjdk-16
  script:
    - cd backend
    - >
      mvn verify sonar:sonar -Dsonar.qualitygate.wait=true
      -Dsonar.projectKey=${SONAR_PROJECT_KEY}
      -Dsonar.host.url=${SONARQUBE_URL}
      -Dsonar.login=${SONAR_LOGIN}
  needs:
    - build-backend-code-job

# frontend:
# в Jenkins использовался nodejs v.16.0
# фронт написан на TypeScript, Angular.
# предпочтительный образ Docker: node:16-bullseye

sonarqube-frontend-sast:
  stage: test
  image: node:16-bullseye
  script:
    - cd frontend
	- >
	  sonar-scanner verify -Dsonar.qualitygate.wait=true \
      -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
      -Dsonar.sources=. \
      -Dsonar.host.url=${SONARQUBE_URL} \
      -Dsonar.login=${SONAR_LOGIN}
  allow_failure: true
  needs:
    - build-frontend-code-job