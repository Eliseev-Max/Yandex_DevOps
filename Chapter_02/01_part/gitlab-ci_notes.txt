# Заметки о .gitlab-ci.yml
# https://kuzevanov.ru/devops/%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%BA%D0%B0-%D0%BF%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8E-gitlab-pipelines.html

#########################################
# Разделение backend и frontend сборок: #
#########################################

stages:
  - triggers
 
trigger_backend:
  stage: triggers
  trigger:
    include: backend/.gitlab-ci.yml		# инклудит код из дочернего .gitlab-ci.yml для бэкенда, если сработал тригер 
  rules:
    - changes:
        - backend/*
 
trigger_frontend:
  stage: triggers
  trigger:
    include: frontend/.gitlab-ci.yml	# инклудит код из дочернего .gitlab-ci.yml для фронтенда, если сработал тригер 
  rules:								# правила запуска джобы
    - changes:
        - frontend/*

---

‼ есть две стадии, которые не требуют предварительного определения в stages:
  • .pre  - запускает до выполнения основных заданий конвейера
  • .post  - выполняется в конце, после выполнения основных заданий нашего пайплайна

Пример:
# .gitlab-ci.yml
stages:
  - build
  - test

getVersion:
  stage: .pre
  script:
    - VERSION=$(cat VERSION_FILE")					# определяем переменную с версией
    - echo "VERSION=${VERSION}" > variables.env		# передаём полученную переменную артефактом в качестве системной переменной $VERSION
  artifacts:
    reports:
      dotenv: variables.env

---
Операция before_script:
  - определяет список команд, которые должны выполняться перед опцией script и после получения артефактов

---
Три формы записи в script:
  1. Описание массива команд

TASK_NAME:
  ...
  script:
    - command1
    - command2
>-<

  2. Длинные команды, разбитые на несколько строк

TASK_NAME:
  ...
  script:
    - |
      command_line1
      command_line2
>-<

  3. Многострочные команды. Индикатор >

TASK_NAME:
  ...
  script:
    - >
      command_line1
      command_line1_continue

      command_line2
      command_line2_continue
	  
---
Операция after_script:
  Набор команд, которые запускаются после scripts, даже, при неудачном завершении последнего.

Пример:

TASK_NAME:
  ...
  script:
    ...
  after_script:
    - command1
    - command2
	
---

dependencies
  Используйте ключевое слово dependencies, чтобы определить список заданий, из которых будут браться артефакты.
  Вы также можете задать задание, которое вообще не будет загружать артефакты.

  Если вы не используете зависимости, все артефакты с предыдущих этапов передаются каждому заданию.
  Возможные входы:
    • имена заданий, из которых нужно получить артефакты.
    • пустой массив ([]), чтобы настроить задание на отсутствие загрузки артефактов.


cache
{"Caching in GitLab CI/CD":
  https://docs.gitlab.com/ee/ci/caching/#availability-of-the-cache}

{ source: Лекция Яндекс.DevOps
	Кэш:
	1. Определяется для задач (блок cache);
	2. Последующие конвейеры могут использовать кэш;
	3. Последующие задачи в том же конвейере могут использовать кэш, если зависимости идентичны;
	4. Разные проекты НЕ МОГУТ использовать кэш совместно;
	5. Кэш хранится там, где запускается Gitlab Runner и загружается в S3, если включен распределённый кэш
}
  
После определения кэша в файле .gitlab-ci.yml доступность кэша зависит от:
    ► типа исполнителя runner;
    ► используются ли разные исполнители для передачи кэша между заданиями.

Где хранятся кэши

	Все кэши, определенные для задания, архивируются в одном файле cache.zip.
	Конфигурация ранера (runner) определяет, где хранится этот файл.
	По умолчанию кэш хранится на машине, где установлен GitLab Runner.
	Расположение также зависит от типа исполнителя.

‼ Если вы используете кэш и артефакты для хранения одного и того же пути в заданиях,
кэш может быть перезаписан, поскольку кэш восстанавливается раньше артефактов.

Имена ключей кэша
	К ключу кэша добавляется суффикс, за исключением ключа резервного кэша.
	В качестве примера предположим, что cache.key установлен в $CI_COMMIT_REF_SLUG, и что у нас есть две ветви main и feature, тогда в следующей таблице представлены результирующие ключи кэша:
	Branch name						Cache key
	main							main-protected
	feature							feature-non-protected
	
	Разделение кэша с помощью имен ключей кэша является функцией безопасности

Использовать один и тот же кэш для всех ветвей
	Если вы не хотите использовать имена ключей кэша, вы можете заставить все ветви (защищенные и незащищенные) использовать один и тот же кэш.
	Разделение кэша с помощью имен ключей кэша является функцией безопасности и должно быть отключено только в среде,
	где все пользователи с ролью Developer имеют высокий уровень доверия.

  Чтобы использовать один и тот же кэш для всех веток:
    1. На верхней панели выберите Главное меню > Проекты и найдите свой проект.
    2. На левой боковой панели выберите Настройки > CI/CD.
    3. Разверните Общие конвейеры.
    4. Снимите флажок Использовать отдельные кэши для защищенных ветвей.
    5. Выберите Сохранить изменения

Как работает архивирование и извлечение

# .gitlab-ci.yml example

stages:
  - build
  - test

before_script:
  - echo "Hello"

job A:
  stage: build
  script:
    - mkdir vendor/
    - echo "build" > vendor/hello.txt
  cache:
    key: build-cache
    paths:
      - vendor/
  after_script:
    - echo "World"

job B:
  stage: test
  script:
    - cat vendor/hello.txt
  cache:
    key: build-cache
    paths:
      - vendor/

Если на одной машине установлен один runner, то все задания для вашего проекта выполняются на одном хосте:
Последовательность действий:
  1. Запускается конвейер
  2. запускается задание A
  3. выполняется before_script
  4. выполняется script
  5. выполняется after_script
  6. запускается cache, и каталог vendor/ запечатывается в файл cache.zip. Затем этот файл сохраняется в директории в соответствии с настройками runner'а и ключом cache:.
  7. Запускается задание B.
  8. Кэш извлекается (если найден).
  9. выполняется before_script
  10. выполняется script
  11. Конвейер завершается.

Используя один runner на одной машине, вы не столкнетесь с проблемой, когда job B может выполняться на runner, отличном от job A.
Такая установка гарантирует возможность повторного использования кэша между этапами.
Она работает только в том случае, если выполнение проходит от этапа сборки до этапа тестирования на одном и том же runner/машине.
В противном случае кэш может быть недоступен.

В процессе кэширования также необходимо учитывать несколько моментов:
  * если какое-то другое задание с другой конфигурацией кэша сохранило свой кэш в том же zip-файле, он будет перезаписан.
    Если используется общий кэш на базе S3, файл дополнительно загружается в S3 в объект, основанный на ключе кэша.
    Таким образом, два задания с разными путями, но одинаковым ключом кэша, перезаписывают свой кэш.
  
  * при извлечении кэша из cache.zip все, что находится в zip-файле, извлекается в рабочую директорию задания
    (обычно это хранилище, которое снесено вниз), и runner не возражает, если архив job A перезапишет что-то в архиве job B.

Это работает так, потому что кэш, созданный для одного runner'а, часто не действителен при использовании другим runner'ом.
Другая программа может работать на другой архитектуре (например, если кэш включает двоичные файлы).

Кроме того, поскольку различные шаги могут выполняться runner'ами, работающими на разных машинах, это является безопасным по умолчанию.
