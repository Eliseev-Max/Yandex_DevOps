lСистемы контроля версий. Почему все выбирают Git?

Вопросы урока:
    [?] Почему возникла необходимость использования систем контроля версий (далее — СКВ).
    [?] Преимущества использования СКВ.
    [?] Почему все используют Git, и чем он хорош.
    [?] Как создавать репозитории и переносить в них код.
    [?] Как находить и править проблемы в Git-репозиториях.


Некоторые преимущества Git перед FTP:
	+ удобное отслеживание версий кода;
	+ удобная совместная работа
	+ наличие истории изменений

‼ Если после внесения изменений в локальном репозитории, 
	→ их индексации (git add <changes>),
	→ фиксации состояния локального репозитория (git commit -m "comment")
	→ вливания изменений в центральный репозиторий (git push ...)
	новый файл (=изменение) не появился (при условии отсутствия ошибок)
	НУЖНО проверить файл .gitignore

Внесение изменений в репозиторий. Откат коммитов
<https://git-scm.com/book/ru/v2/%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%92%D0%BD%D0%B5%D1%81%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9>
  $ git cherry-pick
    - берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке.
    Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесёнными в неё изменениями.
    cherry-pick - это альтернатива слиянию веток.
    Когда проделанная работа из тематической ветки готова к интеграции:
      1. переходим на эту ветку и перебазируем её относительно ветки master (или develop и т. д.).
    Когда использовать:
      в тематической ветке присутствует несколько коммитов, и я хочу взять только один из них;
     или
      в тематической ветке только один коммит и я предпочитаю использовать cherry-pick вместо git rebase.

  $ git rebase
    ...

  $ git 

Отличие git revert и git reset:
	• git reset удаляет коммит, в том числе из истории, как будто его не было вообще;
	• git reset может привести к ошибке, если был применён при совместной работе в удалённом публичном репозитории

[подробнее об этом и других основных командах git: https://habr.com/ru/companies/ruvds/articles/599929/]
[Здесь сравнение команд Git: revert, checkout, reset, merge и rebase:→ 
  https://proglib.io/p/sravnenie-5-komand-git-revert-checkout-reset-merge-i-rebase-2020-05-25
]
[видеокурс по Git + GitHub: https://www.youtube.com/playlist?list=PLuY6eeDuleIOMB2R_Kky05ZfiAx2_pbAH]

Популярные модели ветвления:
	1. Подход Trunk-Based Development в разработке.
    2. Модель ветвления Feature Branch Workflow.
    3. Модель ветвления Gitflow.

1. Trunk-Based Development
	Это модель ветвления, в которой участники команды вносят частые небольшие изменения прямо в ветку master.
	Изменения небольшие и частые → такая модель склоняет разработчиков к использованию непрерывной интеграции, сборке, автотестам;
							     → частые коммиты = обязанность разработчиков: нежелание поломать сборку заставляет писать код более внимательно.
	Такой подход гарантирует доступность последней рабочей версии кода по запросу.
	Если принято решение работать через pull-requests:
	  ► что feature-ветки в этом случае должны существовать недолго;
	  ► в одной ветке работает один человек.
	
	Для кого подходит модель Trunk-Based Development?
	  - подходит для опытных команд, на проектах с частыми релизами и налаженными процессами.

	Основные правила Trunk-Based Development:

	  • Короткий срок жизни веток (максимум 2 дня).
	  • Коммиты и pull-реквесты делаются максимально часто.
	  • За счёт частых и небольших изменений постоянно проводится интеграция продукта.
	  • За счёт небольшого объёма изменений легко отследить ошибку.
	  • За счет Feature Flags (включать и выключать функциональность в продукте флагами) можно деплоить код, который не готов.

	Преимущества Trunk-Based Development:
      + эффективна при работе в стартапе, например, для скорейшего создания MVP
      + подразумевает быстрые итерации и процессы
      + подразумевает высокую квалификацию разработчиков и доверие к ним

	Недостатки Trunk-Based Development:
      - модель неэффективна, если у разработчиков недостаточно квалификации или «кредита доверия»
      - плохо работает в больших командах или в связке с Enterprise-продуктом

2. Feature Branch Workflow
	Основная идея модели:
	  ‼ вся работа над новой функциональностью должна производиться в отдельной ветке, а не в ветке master
	
	Для кого подходит модель Feature Branch Workflow?
	  - подходит для разнообразных проектов: и с фиксированной датой релиза и без, с CI/CD и без.
	
	Основные правила Feature Branch Workflow:
	  • Новая функция — новая ветка.
      • Merge и pull-реквесты — возможность для разработчиков вести обсуждение и делать ревью кода.
      • Может использоваться совместно с другими моделями.

	Преимущества Feature Branch Workflow:
	  + простая модель, которую можно использовать как основу для создания собственных правил ветвления
      + позволяет держать ветку master в чистоте, всегда имея последнюю рабочую версию кода
      + универсальная модель для разных команд и разных циклов релиза

	Недостатки Feature Branch Workflow:
	  - простота может создавать трудности при работе в больших командах

3. Gitflow
	Основная идея модели:
	  выстраивается вокруг релиза проекта.
	
	В ней используются две ветки для записи истории проекта:
	  → ветке master хранится официальная история релиза, 
	  → develop служит в качестве интеграционной ветки для новых функций.
	
	Коммиты в ветку master помечаются номером версии (номером релиза).
	
	Каждая новая функциональность должна разрабатываться в отдельной ветке, которые создаются не на основе master, a на основе develop. После завершения работы над новой функциональностью feature-ветка вливается назад в develop, в master новый код напрямую попадать не должен.
	
	Основные правила Gitflow:
	  • Из master создаётся ветка develop.
      • Из develop создаются ветки feature.
      • Когда разработка новой функциональности завершена, она объединяется с веткой develop.
      • Из develop создаётся ветка release.
      • Когда ветка релиза готова, она объединяется с develop и master.
      • Если в master обнаружена проблема, из неё создаётся ветка hotfix.
      • Как только исправление на ветке hotfix завершено, она объединяется с develop и master.

	Преимущества Gitflow:
	  + модель хорошо подходит для работы больших распределённых команд
      + модель эффективна при работе с junior-разработчиками — большое количество итераций до отправки кода в релиз

	Недостатки Gitflow:
	  - модель достаточно медленная, поэтому
	    → получение MVP,			┐
		→ коммуникация сотрудников, ├→  будут происходить неэффективно как в стартапе, так и в небольшой команде
		→ организация процессов 	┘	

[
	https://stackoverflow.com/questions/9059335/how-can-i-get-the-parents-of-a-merge-commit-in-git
	https://translated.turbopages.org/proxy_u/en-ru.ru.d7f250bf-6432e9e3-181e69f6-74722d776562/https/stackoverflow.com/questions/4762906/how-to-rollback-the-two-previous-commits

	https://git-scm.com/docs/git-revert
	https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%9F%D1%80%D0%BE%D0%B4%D0%B2%D0%B8%D0%BD%D1%83%D1%82%D0%BE%D0%B5-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5#r_reverse_commit

]