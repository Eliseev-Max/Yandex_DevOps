Организация резервного копирования
Из этого урока вы научитесь:
  • Понимать, как работают бэкапы, и что это такое.
  • Понимать механику снэпшотов.
  • Находить разницу между бэкапами и снапшотами.
  • Делать полный бэкап инфраструктуры.
  • Понимать, как делать инкрементальный и смешанный бэкапы.
  • Находить отличия между полным, инкрементальным и смешанным бэкапами.
  • Понимать типы ротаций бэкапов по количеству, дате и объёму.
  • Определять частоту и размещение бэкапов в зависимости от ресурсов.
  • Настраивать ротацию бэкапов.


Как работает бэкапирование:
  ○ Есть VM, в которой развёрнута определённая ОС, установлены пакеты и некоторая версия приложения.
  • В момент времени, когда нагрузка на приложение (=систему) минимальна (обычно - ночь/раннее утро)
    делается полный бэкап всей системы;
  ☼ Бэкап перемещается в хранилище = другую VM.

Скрипты выполняютс под "руководством" cron. 
cron — встроенная утилита, запускающая скрипты и программы по расписанию (иногда называют scheduler)

  → просмотр скриптов в текущем расписании:
    $ crontab -l
  
  → внести изменения в текущее расписание:
    $ crontab -e

Синтаксис расписания cron:
  [минута] [час] [день] [месяц] [день_недели] <путь_к_скрипту_или_непосредственно_команда>
  
  Если время запуска неважно, то указывается *
  Пример:
  
  10 3 * * * /home/jarservice/my.sh			# запуск shell-скрипта каждый день в 3:10 утра

  */1 7-19 * * 1 /home/jarservice/my.sh		# запускать каждую минуту понедельника с 7 до 19

‼ понедельник - 1 (первый день)
‼ воскресенье - 7 | 0 (седьмой или нулевой день)

Конфигурирование

  /etc/cron.allow  - в файле можно указать список пользователей, у которых будет доступ к cron
  /etc/cron.deny  - в файле можно указать список пользователей, которым запретим доступ

‼! имена записываются по одному на каждой строчке
‼ Одновременно можно использовать только одного из них.

в файл /etc/crontab тоже иногда записывают расписания


################
# Типы бэкапов #
################

  ♦ Полный бэкап:
    -> когда мы делаем сохранение всей системы целиком.
	# САМЫЙ БЫСТРЫЙ при восстановлении
  
    Создание бэкапа с виртуальной машины обычно не сильно влияет на работу приложения,
	Создание бэкапа базы данных с помощью утилит по созданию дампов вполне может отразиться на пользователях.

  ♦ Инкрементальный бэкап:  
    + делаем новый бэкап, отталкиваясь от ПОЛНОГО;
	+ сохраняем не всё состояние системы, а только то, что изменилось с момента полного или предыдущего инкрементального бэкапа.
	
  ‼ Это НЕ самостоятельный бэкап, а возможность записать поверх основного бэкапа новое состояние.
  Ключевой момент:
  <при воссстановлении>:
    1. сначала берём полный бэкап
	2. последовательно, один за другим, восстанавливаем инкрементальные бэкапы.

  ♦ Дифференциальный бэкап:
    -> почти такой же, как и инкрементальный.
	Разница: 
	  в него записываются не только изменения, сделанные с последнего инкрементального бэкапа, 
	  но и все предыдущие — и так, пока не дойдёт до последнего полного бэкапа.

    Преимущества:
      + экономия времени (достаточно будет восстановить только полный бэкап и затем один дифференциальный,
	  а не всю когорту, как это было бы в инкрементальном)
	
	Недостатки:
	  - требует большего свободного места

Полный бэкап:> 
  * применяется чаще;
  * возможен даже с помощью системных команд

Инкрементальный и дифференциальный бэкапы:>
  * выполняются только с помощью специальных утилит;
  * часто встречаются при работе с БД (pg_dump для PostgreSQL).
  
Инструментарий

  1. rsync
    (grsync - утилита с графическим отображением)
    Особенности:
	  - требует установки утилиты на VM, с которой отправляем бэкап, и на той, куда его отправляем;
	  + по умолчанию присутствует в большей части Linux-систем
	
	Пример резервного копирования:
$ rsync -azvh <b_user>@<ip_сосисочной>:/home/jarservice/sausage-store.jar <b_user>@<ip_бэкапочной>:/mnt/sausage_backup/$(date +"%m-%d-%Y")/ > /var/log/sausage-store.log
# b_user = пользователь_для_бэкапов

#### * полезные атрибуты:

-r    # чтобы работать с папками и их содержимым
--exclude my_file.txt    # чтобы исключить из бэкапа какой-то файл
--delete    # удалять из бэкапа файлы, если они отсутствуют в источнике
-a     # сохранять права на файлы и владельца
-v     # для визуализации бэкапируемых файлов
-h     # для человекочитаемого вывода информации о размерах отправленного
-e, --rsh=COMMAND    # указать удаленную оболочку для использования
--dry-run     # для тестового прогона, без реального перемещения файлов
-z     # сжатие данных

Документация: (http://wiki.opennet.ru/Rsync)

PostgreSQL. Синхронизация данных между базами вручную:
rsync -ar /var/lib/pgsql/data/ <пользователь>@<ip_слейва>:/var/lib/pgsql/data/ --exclude postmaster.pid


#####################
# Снапшоты и бэкапы #
#####################

  Снапшоты (снимки состояния виртуальных машин)
    - это одна из разновидностей резервного копирования
  
  В момент создания снапшота виртуальной машины:
    • прекращается запись на её диск;
	• последующие операции записи проводятся уже в отдельный файл.
	
‼!НЕ РЕКОМЕНДУЕТСЯ:
    - создавать более трёх снапшотов
	    (последующие будут негативно влиять на производительность работы VM)
	
	- устанавливать продолжительность жизни одного снимка дольше 72 часов
	    (иначе его размер станет очень большим, а VM будет работать очень медленно)
  
В каком случае снапшоты наиболее выгодно использовать?
  - когда надо попробовать какую-то экспериментальную вещь, (в случае провала можно сразу откатиться к оригинальному состоянию)


###################
# Ротация бэкапов #
###################

  «Классическая ротация»:
    новый файл создаётся по определённым принципам, таким как время или размер, а старый файл удаляется.

  «Дед-отец-сын» (grandfather-father-son — GFS):
     - раз в неделю делается полный бэкап «отец»,
	 - затем ежедневно создаются инкрементальные или дифференциальные «сыновья» 
	(→) и так до следующего полного бэкапа.
	 - раз в месяц, обычно в последний день, выполняется дополнительный полный бэкап «дед»
  "+" - более рациональное использование диска;
  "-" - больше времени на восстановление.

  Схема "Отец-сын":
    (-) сокращает отказоустойчивость;
    (+) простота и удобство (подходит небольшим компаниям)

  * предполагается, что для каждого родственника будет использоваться своё хранилище данных, на случай подстраховки
  
Настройка ежедневного запуска команды на очистку старых файлов в cron:
  
  0 3 * * * find /mnt/sausage_backup/ -name "sausage-store.jar" -type f -mtime +14 -delete
  
# каждый день в 3 утра будет запускаться команда по поиску файлов с бэкендом старше, чем 2 недели и удалять их
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
‼ В "шестом" поле (оставшаяся часть строки) указывается выполняемая команда.
Вся командная часть строки, вплоть до новой строки или символа %, будет выполнена командой /bin/sh или оболочкой, указанной в переменной SHELL cronfile.
‼! Знаки процента (%) в команде, если они не экранированы обратным слешем (\), будут заменены на символы новой строки, а все данные после первого % будут переданы команде в качестве стандартного ввода.
!!!!!!!!!!!!!

# О том, как использовать cron и создавать задачи с помощью crontab:
# https://losst.pro/nastrojka-cron


Ротация логов. logrotate
  Механизм logrotate:
    - создать в папке /etc/logrotate.d/ файл с нужными параметрами
	→ дальше оно само отрабатывает

# (О том, как заруинили БД GitLab.com: https://habr.com/ru/companies/southbridge/articles/321074/)
# (Случай в Pixar или еще раз о важности тестирования резервных копий:
https://habr.com/ru/companies/veeam/articles/193568/)


Специальные термины
  RPO (Recovery Point Objective) — это время, за которое могут быть потеряны данные.
  RTO (Recovery Time Objective) — это время, пока система может быть недоступной в случае аварии.
     ~ допустимое время восстановления данных из бэкапа.

  Глубина хранения (глубина бэкапа) обозначает время хранения резервной копии.

---
Внезапная задача

Возьмём сферического коня в вакууме, которым в нашем случае будет БД с изначальным размером 10 ГБ, куда каждый час записывается по 5 МБ.
Для этой базы данных предусмотрена система бэкапирования по системе «дед-отец-сын». Бэкапы делаются инкрементные, а не дифференциальные. Полные бэкапы выполняются по понедельникам. Все бэкапы делаются в конце дня. Также представим, что у нас сначала удаляется устаревшая версия бэкапа, а потом записывается новая.

Какого размера хранилище нам надо развернуть, чтобы цикл бэкапирования включал 1 месяц (предположим, что месяц у нас ровно 28 дней, то есть 4 недели)?

Эталонный расчёт выглядит следующим образом:

Правильный ответ — ~60 ГБ, а точнее 61,7 ГБ. Как это получилось. Каждый день наша база порождает: 5 МБ * 24 часа = 120 МБ — и так к концу первой недели размер базы увеличивается до 120 МБ * 7 дней = 840 МБ + стартовые 10 ГБ. Всё это мы сохранили в хранилище.
Хранилище: 10 ГБ 840 МБ

Вторая неделя начинается с «отца», который сохраняет полный бэкап текущего состояния + то, что успело набежать за день: 10 ГБ 840 МБ + 120 МБ = 10 ГБ 960 МБ. Дальше шли обычные «сыны» 6 дней, давшие нам ещё 720 МБ. Итого за вторую неделю = 11 ГБ 680 МБ.
Хранилище: 22 ГБ 520 МБ

Третья неделя — по механике похожа на вторую. Ещё 12 ГБ 520 МБ.
Хранилище: 35 ГБ 40 МБ

Четвёртая неделя (последняя неделя месяца), как вторая и третья, но в конце мы добавляем ещё один полный бэкап — «дед». 12 ГБ 520 МБ + 840 МБ = 13 ГБ 360 МБ * 2 = 26 ГБ 720 МБ
Хранилище: 61 ГБ 760 МБ

---

Общая информация о Яндекс.Облаке
Яндекс.Облако — облачный провайдер с возможностью создавать в нём виртуальные машины, базы и много чего ещё полезного.
Устройство:
  • у пользователя есть доступ к облакам,
  • облака содержат каталоги, 
  • каталоги содержат различные ресурсы (виртуальные машины, диски, подсети и другое):
####
  Облако:
  Каталог:
    Ресурс_1
    Ресурс_2
####

# Скрипт от Василия
#!/bin/bash
cd /opt/backup/
ls -1 -r | tail -n +31 | xargs rm -rf


#!/bin/bash
cd /opt/backup/
ls -1 -r | tail -n +31 | xargs rm -rf