Using SSH keys with GitLab CI/CD
(https://docs.gitlab.com/ee/ci/ssh_keys/)

В настоящее время GitLab не имеет встроенной поддержки для управления ключами SSH в среде сборки
  (среде в которой работает GitLab Runner).
  
Используйте SSH-ключи, когда вам это необходимо:
  * Проверить внутренние подмодули.
  * Загрузить личные пакеты с помощью менеджера пакетов. Например, Bundler.
  * Развернуть свое приложение на собственном сервере или, например, на Heroku.
  * Выполнять SSH-команды из среды сборки на удаленный сервер.
  * Rsync-файлы из среды сборки на удаленный сервер.
  
Если что-то из вышеперечисленного вам знакомо, то, скорее всего, вам нужен SSH-ключ.

Наиболее широко поддерживаемым методом является внедрение SSH-ключа в среду сборки путем расширения .gitlab-ci.yml,
и это решение работает с любым типом исполнителя (например, Docker или shell).

Как это работает

  1. Создаём новую пару SSH-ключей локально с помощью ssh-keygen;
  2. Добавляем в наш проект private key как переменную CI/CD файлового типа;
  3. Запустим ssh-agent во время выполнения задания для загрузки закрытого ключа;
  4. Скопируем открытый ключ на серверы, к которым хотим иметь доступ
    (обычно в ~/.ssh/authorized_keys), или добавим его в качестве ключа развертывания, если нужно получить доступ к закрытому репозиторию GitLab

В следующем примере команда ssh-add не отображает значение $SSH_PRIVATE_KEY в журнале заданий,
хотя оно может быть открыто, если вы включите отладочную регистрацию.
Возможно, вы также захотите проверить видимость ваших конвейеров

Ключи SSH при использовании исполнителя Docker

  Когда ваши задания CI/CD выполняются в контейнерах Docker (то есть среда содержится) и вы хотите развернуть свой код на частном сервере,
  вам нужен способ доступа к нему.
  В этом случае вы можете использовать пару ключей SSH.
    1. Сначала необходимо создать пару ключей SSH.
	   (следуйте инструкциям по созданию ключа SSH).
	   ‼! Не добавляйте парольную фразу (passphrase) к SSH-ключу, иначе скрипт before_script запросит ее.

    2. Создайте новую переменную CI/CD типа файл.
	   В качестве Key введите имя SSH_PRIVATE_KEY, а в поле Value вставьте содержимое вашего закрытого ключа, который вы создали ранее.

    3. Модифицируйте ваш .gitlab-ci.yml с помощью действия before_script.
	
	Пример:
	( * образ основан на Debian)
	
before_script:
  ##
  ## Install ssh-agent if not already installed, it is required by Docker.
  ## (change apt-get to yum if you use an RPM-based image)
  ##
  - 'command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )'

  ##
  ## Run ssh-agent (inside the build environment)
  ##
  - eval $(ssh-agent -s)

  ##
  ## Установите правильные права, иначе ssh-add откажется добавлять файлы
  ## Добавьте ключ SSH, хранящийся в переменной CI/CD типа файла SSH_PRIVATE_KEY, в хранилище агентов
  ##
  - chmod 400 "$SSH_PRIVATE_KEY"
  - ssh-add "$SSH_PRIVATE_KEY"

  ##
  ## Создайте директорию SSH и дайте ей необходимые разрешения
  ##
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh

  ##
  ## По желанию, если вы будете использовать какие-либо команды Git, задайте имя пользователя
  ## и email.
  ##
  # - git config --global user.email "user@example.com"
  # - git config --global user.name "User name"


  ‼ Параметр before_script может быть установлен
    - глобально
        или
    - для каждого задания

    4. Убедитесь, что ключи SSH хоста частного сервера проверены.

    5. В качестве последнего шага добавьте открытый ключ, созданный в первом шаге, к сервисам, к которым вы хотите иметь доступ из среды сборки.
	   Если вы получаете доступ к закрытому репозиторию GitLab, вы должны добавить его в качестве ключа развертывания.

Verifying the SSH host keys
(https://docs.gitlab.com/ee/ci/ssh_keys/#verifying-the-ssh-host-keys)

Хорошей практикой является проверка собственного открытого ключа частного сервера.
  Цель: убедиться, что вы не являетесь целью MITM (man-in-the-middle) атаки.
Если происходит что-то подозрительное, вы заметите это, потому что задание не выполняется
(SSH-соединение не работает, когда открытые ключи не совпадают).

Чтобы узнать ключи хоста вашего сервера, выполните команду ssh-keyscan из доверенной сети
(в идеале - с самого private-сервера)
  ## Используя доменное имя
	ssh-keyscan example.com

	## Или используя IP
	ssh-keyscan 1.2.3.4

Создайте новую CI/CD переменную ФАЙЛОВОГО ТИПА с SSH_KNOWN_HOSTS в качестве "Key", а в качестве "Value" добавьте вывод ssh-keyscan.
  SSH_KNOWN_HOSTS:<ssh-keyscan output>

Если вам необходимо подключиться к нескольким серверам, все ключи хостов серверов должны быть собраны в Value переменной,
по одному ключу в строке.

Преимущество использования переменной CI/CD типа файла вместо ssh-keyscan непосредственно внутри .gitlab-ci.yml:
  + не придется менять .gitlab-ci.yml, если имя домена хоста по какой-то причине изменится.
  + значения предопределены нами -> если ключи хоста внезапно изменятся, задание CI/CD не завершится неудачей,
  -> значит, что-то не так с сервером или сетью.

Теперь, когда переменная SSH_KNOWN_HOSTS создана, в дополнение к содержимому .gitlab-ci.yml выше, вы должны добавить:

before_script:
  ##
  ## Предполагая, что вы создали CI/CD переменную SSH_KNOWN_HOSTS файлового типа, 
  ## откомментируйте следующие две строки.
  #- cp "$SSH_KNOWN_HOSTS" ~/.ssh/known_hosts
  #- chmod 644 ~/.ssh/known_hosts

  ##
  ## В качестве альтернативы используйте ssh-keyscan для сканирования ключей вашего частного сервера. 
  ## Замените example.com на доменное имя вашего частного сервера
  ## Повторите эту команду, если у вас есть несколько серверов для подключения
  ##
  # - ssh-keyscan example.com >> ~/.ssh/known_hosts
  # - chmod 644 ~/.ssh/known_hosts

  ##
  ## По желанию можно отключить проверку ключей хоста. 
  ## Имейте в виду, что, добавив это, вы станете уязвимы для атак типа MITM.
  ## ВНИМАНИЕ: Используйте это только с исполнителем Docker! 
  ## если вы используете это с shell, вы перезапишите SSH-конфигурацию вашего пользователя.
  ##
  # - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" >> ~/.ssh/config'